<!DOCTYPE html>
<html lang="en">
	<head>
		<title>换热器设计 V0.00</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="css/main.css">
	</head>
	<body>
		<div id="info">
			换热器设计<br/><br/>
		</div>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/STLExporter.js"></script>
		<script src="js/stats.min.js"></script>
		<script src="js/dat.gui.module.js"></script>
		<script src="js/Three.Extended.min.js"></script>
		<script type="module">

var container, stats;
var camera, scene, renderer, controls;
var raycaster = new THREE.Raycaster();

var mouse = new THREE.Vector2();
var selectedObjects = [];

var composer, effectFXAA, outlinePass;
var obj3d = new THREE.Object3D();

var group = new THREE.Group();

// Init gui
var gui = new GUI( { width: 300 } );

var finsFeatures={
	di:10.4,//管道内径di
	db:12.4,//管道外径(不含齿高)db
};

var finsGUI = gui.addFolder('翅片属性设置');

finsGUI.add( finsFeatures, 'di', 10, 30 ).onChange( function ( value ) {
	finsFeatures.di = Number( value );
} ).name('管道内径di');

finsGUI.add( finsFeatures, 'db', 12.0, 24 ).onChange( function ( value ) {
	finsFeatures.db = Number( value );
} ).name('管道外径(不含齿高)db');

var TubeFeatures=function(){
	this.Qk=46000;//冷凝负荷Qk
	this.qo=6000;//管外热流密度qo
	this.Download_STL_File = function() {
		// Instantiate an exporter
		var exporter = new THREE.STLExporter();

		// Parse the input and generate the ply output
		var buffer = exporter.parse(scene, { binary: true } );
		var blob=new Blob( [ buffer ], { type: 'application/octet-stream' } );
		var link = document.createElement( 'a' );
		link.href = URL.createObjectURL( blob );
		link.download = '换热器模型.stl';
		link.dispatchEvent( new MouseEvent( 'click' ) );
	};
};

var tubeFeatures=new TubeFeatures();
var tubeGUI = gui.addFolder('管道属性设置');

tubeGUI.add( tubeFeatures, 'Qk', 45000, 100000 ).onChange( function ( value ) {
	tubeFeatures.Qk = Number( value );
} ).name('冷凝负荷Qk');

tubeGUI.add( tubeFeatures, 'qo', 5000, 10000 ).onChange( function ( value ) {
	tubeFeatures.qo = Number( value );
} ).name('管外热流密度qo');

tubeGUI.add(tubeFeatures, 'Download_STL_File').name('导出stl文件');

var params = {
	edgeStrength: 3.0,
	edgeGlow: 0.0,
	edgeThickness: 1.0,
	pulsePeriod: 0,
	rotate: false,
};

var outlineGUI = gui.addFolder('Outline Features');

outlineGUI.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {
	outlinePass.edgeStrength = Number( value );
} );

outlineGUI.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {
	outlinePass.edgeGlow = Number( value );
} );

outlineGUI.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {
	outlinePass.edgeThickness = Number( value );
} );

outlineGUI.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {
	outlinePass.pulsePeriod = Number( value );
} );
outlineGUI.add( params, 'rotate' );


var Configuration = function () {
	this.visibleEdgeColor = '#ffffff';
	this.hiddenEdgeColor = '#190a05';
};

var conf = new Configuration();

outlineGUI.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {
	outlinePass.visibleEdgeColor.set( value );
} );

outlineGUI.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {
	outlinePass.hiddenEdgeColor.set( value );
} );

init();
animate();

function init() {

	container = document.createElement( 'div' );
	document.body.appendChild( container );

	var width = window.innerWidth;
	var height = window.innerHeight;

	renderer = new THREE.WebGLRenderer();
	renderer.shadowMap.enabled = true;
	// todo - support pixelRatio in this demo
	renderer.setSize( width, height );
	document.body.appendChild( renderer.domElement );

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 100 );
	camera.position.set( 0, 0, 8 );

	controls = new THREE.OrbitControls( camera, renderer.domElement );
	controls.minDistance = 5;
	controls.maxDistance = 40;
	controls.enablePan = false;
	controls.enableDamping = true;
	controls.dampingFactor = 0.05;

	//

	scene.add( new THREE.AmbientLight( 0xaaaaaa, 0.2 ) );

	var light = new THREE.DirectionalLight( 0xddffdd, 0.6 );
	light.position.set( 1, 1, 1 );

	light.castShadow = true;

	light.shadow.mapSize.width = 1024;
	light.shadow.mapSize.height = 1024;

	var d = 10;

	light.shadow.camera.left = - d;
	light.shadow.camera.right = d;
	light.shadow.camera.top = d;
	light.shadow.camera.bottom = - d;

	light.shadow.camera.far = 1000;

	scene.add( light );

	// tube model
	function CustomSinCurve( scale ) {
		THREE.Curve.call( this );
		this.scale = ( scale === undefined ) ? 1 : scale;
	}

	CustomSinCurve.prototype = Object.create( THREE.Curve.prototype );
	CustomSinCurve.prototype.constructor = CustomSinCurve;
	CustomSinCurve.prototype.getPoint = function ( t ) {
		var tx = t * 3 - 1.5;
		var ty = Math.sin( 2 * Math.PI * t );
		var tz = 0;

		return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );

	};

	var tubePath = new CustomSinCurve( 10 );
	var tubeGeometry = new THREE.TubeGeometry( tubePath, 20, 2, 8, false );
	var tubeMaterial = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide });//侧面渲染方式 两面
	tubeMaterial.color.setHSL( Math.random(), 1.0, 0.3 );
	var tubeMesh = new THREE.Mesh( tubeGeometry, tubeMaterial );

	tubeMesh.position.x = 0;
	tubeMesh.position.y = 0;
	tubeMesh.position.z = 2;

	tubeMesh.scale.multiplyScalar( 0.1 );

	tubeMesh.receiveShadow = true;
	tubeMesh.castShadow = true;

	obj3d.add( tubeMesh );

	scene.add( group );
	group.add( obj3d );

	//

	var geometry = new THREE.SphereBufferGeometry( 3, 48, 24 );

	for ( var i = 0; i < 10; i ++ ) {

		var material = new THREE.MeshLambertMaterial();
		material.color.setHSL( Math.random(), 1.0, 0.3 );

		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.x = Math.random() * 4 - 2;
		mesh.position.y = Math.random() * 4 - 2;
		mesh.position.z = Math.random() * 4 - 2;
		mesh.receiveShadow = true;
		mesh.castShadow = true;
		mesh.scale.multiplyScalar( Math.random() * 0.3 + 0.1 );
		group.add( mesh );

	}

	var floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );

	var floorGeometry = new THREE.PlaneBufferGeometry( 12, 12 );
	var floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
	floorMesh.rotation.x -= Math.PI * 0.5;
	floorMesh.position.y -= 1.5;
	group.add( floorMesh );
	floorMesh.receiveShadow = true;

	var geometry = new THREE.TorusBufferGeometry( 1, 0.3, 16, 100 );
	var material = new THREE.MeshPhongMaterial( { color: 0xffaaff } );
	var torus = new THREE.Mesh( geometry, material );
	torus.position.z = - 4;
	group.add( torus );
	torus.receiveShadow = true;
	torus.castShadow = true;

	//

	stats = new Stats();
	container.appendChild( stats.dom );

	// postprocessing

	composer = new EffectComposer( renderer );

	var renderPass = new RenderPass( scene, camera );
	composer.addPass( renderPass );

	outlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
	composer.addPass( outlinePass );


	effectFXAA = new ShaderPass( FXAAShader );
	effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
	composer.addPass( effectFXAA );

	window.addEventListener( 'resize', onWindowResize, false );

	window.addEventListener( 'mousemove', onTouchMove );
	window.addEventListener( 'touchmove', onTouchMove );

	function onTouchMove( event ) {

		var x, y;

		if ( event.changedTouches ) {

			x = event.changedTouches[ 0 ].pageX;
			y = event.changedTouches[ 0 ].pageY;

		} else {

			x = event.clientX;
			y = event.clientY;

		}

		mouse.x = ( x / window.innerWidth ) * 2 - 1;
		mouse.y = - ( y / window.innerHeight ) * 2 + 1;

		checkIntersection();

	}

	function addSelectedObject( object ) {
		selectedObjects = [];
		selectedObjects.push( object );
		console.info("You click",object);
	}

	function checkIntersection() {

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( [ scene ], true );

		if ( intersects.length > 0 ) {

			var selectedObject = intersects[ 0 ].object;
			addSelectedObject( selectedObject );
			outlinePass.selectedObjects = selectedObjects;

		} else {

			// outlinePass.selectedObjects = [];

		}

	}

}

function onWindowResize() {

	var width = window.innerWidth;
	var height = window.innerHeight;

	camera.aspect = width / height;
	camera.updateProjectionMatrix();

	renderer.setSize( width, height );
	composer.setSize( width, height );

	effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );

}

function animate() {

	requestAnimationFrame( animate );

	stats.begin();

	var timer = performance.now();

	if ( params.rotate ) {

		group.rotation.y = timer * 0.0001;

	}

	controls.update();

	composer.render();

	stats.end();

}

		</script>
	</body>
</html>
